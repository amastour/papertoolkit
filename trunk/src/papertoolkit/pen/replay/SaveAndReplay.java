package papertoolkit.pen.replay;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import javax.swing.JFileChooser;

import papertoolkit.PaperToolkit;
import papertoolkit.events.EventDispatcher;
import papertoolkit.events.PenEvent;
import papertoolkit.events.PenEventType;
import papertoolkit.pen.InputDevice;
import papertoolkit.pen.PenSample;
import papertoolkit.pen.streaming.listeners.PenListener;
import papertoolkit.util.DebugUtils;
import papertoolkit.util.files.FileUtils;

/**
 * <p>
 * This class interacts with the EventEngine to simulate real-time input events. The events can be loaded from
 * disk (XML files), and can be either batched or realtime events. Alternatively, events generated by an
 * actual pen can be saved out to a file, for future replay.
 * </p>
 * <p>
 * <span class="BSDLicense"> This software is distributed under the <a
 * href="http://hci.stanford.edu/research/copyright.txt">BSD License</a>. </span>
 * </p>
 * 
 * @author <a href="http://graphics.stanford.edu/~ronyeh">Ron B Yeh</a> (ronyeh(AT)cs.stanford.edu)
 */
public class SaveAndReplay {

	/**
	 * Event Data files are of the form *.eventData.
	 */
	public static final String[] FILE_EXTENSION = new String[] { "eventData" };

	private static SaveAndReplay instance;

	public static synchronized SaveAndReplay getInstance() {
		if (instance == null) {
			instance = new SaveAndReplay();
		}
		return instance;
	}

	private HashMap<InputDevice, PenListener> inputDeviceToListener = new HashMap<InputDevice, PenListener>();

	/**
	 * Events that we can replay...
	 */
	private ArrayList<PenEvent> loadedEvents = new ArrayList<PenEvent>();

	/**
	 * Allows us to write to our output file for serializing the event stream.
	 */
	private PrintWriter output;

	/**
	 * Should we play back the pen events in real time. That is, if there is a one second pause between two
	 * pen taps, true --> we replicate that one second pause, false --> we replay it as fast as possible.
	 */
	private boolean playEventsInRealTime = true;

	/**
	 * 
	 */
	private InputDevice lastPenUsed;

	private PenSample lastPenSampleTracked;

	/**
	 * Record input at the InputDevice level, and replay to PenListeners.... This should work for multiple
	 * pens...
	 * 
	 * @param inputDevice
	 */
	private SaveAndReplay() {

	}

	private void checkIfNewPen(InputDevice inputDevice) {
		// if it's a new pen, inject some xml to close the previous pen, and open a new one...
		if (inputDevice != lastPenUsed) {
			// add XML tag to tell us a pen was changed...
			output.println("<pen id=\"" + inputDevice.getID() + "\"/>");
		}
		lastPenUsed = inputDevice;
	}

	/**
	 * 
	 */
	public void clearLoadedEvents() {
		loadedEvents = new ArrayList<PenEvent>();
	}

	/**
	 * @return
	 */
	private File getEventStoragePath() {
		return new File(PaperToolkit.getToolkitRootPath(), "eventData/");
	}

	// if we never write to it, the file should never be created...
	private void lazyInitOutputFile() {
		if (output == null) {
			try {
				// Write events to disk (autoflushed), so that we can replay sessions in the
				// future.
				File outputFile = new File(getEventStoragePath(), FileUtils
						.getCurrentTimeForUseInASortableFileName()
						+ ".eventData");
				output = new PrintWriter(new FileOutputStream(outputFile), true /* autoflush */);
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}
		}
	}

	public PenListener getPenListener(final InputDevice inputDevice) {
		PenListener penListener = inputDeviceToListener.get(inputDevice);
		if (penListener == null) {
			penListener = new PenListener() {
				public void penDown(PenSample sample) {
					lazyInitOutputFile();
					checkIfInteractionGap(sample);
					checkIfNewPen(inputDevice);
					saveSample(sample);
				}

				public void penUp(PenSample sample) {
					checkIfNewPen(inputDevice);
					lastPenSampleTracked = sample;
					saveSample(sample);
				}

				public void sample(PenSample sample) {
					checkIfNewPen(inputDevice);
					lastPenSampleTracked = sample;
					saveSample(sample);
				}
			};
			inputDeviceToListener.put(inputDevice, penListener);
		}
		return penListener;
	}

	private void checkIfInteractionGap(PenSample sample) {
		if (lastPenSampleTracked != null) {
			long diff = sample.timestamp - lastPenSampleTracked.timestamp;
			if (diff > 1000) { // 10 seconds
				output.println("<gap time=\"" + diff + "\"/>");
			}
		}
		lastPenSampleTracked = sample;
	}

	/**
	 * 
	 */
	public void importEventDataFromFileChooser() {
		JFileChooser chooser = FileUtils.createNewFileChooser(SaveAndReplay.FILE_EXTENSION);
		chooser.setCurrentDirectory(new File(PaperToolkit.getToolkitRootPath(), "eventData/"));
		chooser.setMultiSelectionEnabled(true);
		int result = chooser.showDialog(null, "Import Event Data");
		if (result == JFileChooser.APPROVE_OPTION) {
			File[] selectedFiles = chooser.getSelectedFiles();
			for (File f : selectedFiles) {
				// DebugUtils.println("Loading " + f);
				loadEventDataFrom(f);
			}
		}
	}

	/**
	 * @param eventDataFile
	 */
	public void loadEventDataFrom(File eventDataFile) {
		BufferedReader br;
		try {
			br = new BufferedReader(new FileReader(eventDataFile));
			String inputLine = null;
			while ((inputLine = br.readLine()) != null) {
				PenEvent event = null; /* TODO */
				loadedEvents.add(event);
			}
			// DebugUtils.println("Loaded " + loadedEvents.size() + " events.");
			br.close();
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}

	}

	/**
	 * Load the most recent event data file...
	 */
	public void loadMostRecentEventData() {
		final List<File> eventFiles = FileUtils.listVisibleFiles(getEventStoragePath(), FILE_EXTENSION);
		if (eventFiles.size() > 0) {
			final File mostRecentFile = eventFiles.get(eventFiles.size() - 1);
			DebugUtils.println(mostRecentFile);
			loadEventDataFrom(mostRecentFile);
		} else {
			DebugUtils.println("No Event Data Files Found in " + getEventStoragePath());
		}
	}

	/**
	 * Replay the events that have been loaded, in the order that they appear in the list...
	 */
	public void replayLoadedEvents(EventDispatcher eventEngine) {
		replayToEventDispatcher(eventEngine, loadedEvents);
	}

	/**
	 * Replays the list of events... Ideally, this should play it back at real time or some multiple of
	 * realtime...
	 * 
	 * Threaded, because we do not want any GUI to block when calling this. Alternatively, refactor this into
	 * blocking & nonblocking versions.
	 * 
	 * @param eventDispatcher
	 *            We will dispatch events to this event engine, simulating input from one or more pens...
	 *            eventEngine = engine;
	 * @param events
	 */
	private void replayToEventDispatcher(final EventDispatcher eventDispatcher, final List<PenEvent> events) {
		new Thread(new Runnable() {
			public void run() {
				long lastTimeStamp = 0;
				for (PenEvent event : events) {
					if (playEventsInRealTime && lastTimeStamp != 0) {
						try {
							// pause some amount, to replicate realtime...
							long diff = event.getTimestamp() - lastTimeStamp;
							if (diff > 0) {
								// DebugUtils.println("Sleeping for " + diff + " ms between
								// events.");
								Thread.sleep(diff);
							}
						} catch (InterruptedException e) {
							e.printStackTrace();
						}

					}

					// assume here that all PenEvent objects have their flags set correctly
					eventDispatcher.handlePenEvent(event);
					lastTimeStamp = event.getTimestamp();
				}
				// DebugUtils.println("Done. Replayed " + events.size() + " Events");
			}
		}).start();
	}

	/**
	 * Save this pen event. This is done automatically for events streamed through any Pen, allowing arbitrary
	 * save and replay of user interactions. One event file is created for each "test session."
	 * 
	 * @param event
	 */
	private void saveSample(PenSample sample) {
		output.println(sample.toXMLString());
	}

}
