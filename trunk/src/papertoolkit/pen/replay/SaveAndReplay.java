package papertoolkit.pen.replay;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.swing.JFileChooser;

import papertoolkit.PaperToolkit;
import papertoolkit.events.EventDispatcher;
import papertoolkit.events.PenEvent;
import papertoolkit.events.PenEventType;
import papertoolkit.pen.InputDevice;
import papertoolkit.pen.PenSample;
import papertoolkit.pen.streaming.listeners.PenListener;
import papertoolkit.util.DebugUtils;
import papertoolkit.util.files.FileUtils;

/**
 * <p>
 * This class interacts with the EventEngine to simulate real-time input events. The events can be loaded from
 * disk (XML files), and can be either batched or realtime events. Alternatively, events generated by an
 * actual pen can be saved out to a file, for future replay.
 * </p>
 * <p>
 * <span class="BSDLicense"> This software is distributed under the <a
 * href="http://hci.stanford.edu/research/copyright.txt">BSD License</a>. </span>
 * </p>
 * 
 * @author <a href="http://graphics.stanford.edu/~ronyeh">Ron B Yeh</a> (ronyeh(AT)cs.stanford.edu)
 */
public class SaveAndReplay {

	private static enum ReplayEventType {
		TIME_GAP, PEN_CHANGE, SAMPLE
	}

	private static class ReplayEvent {
		public ReplayEventType type;
		public PenSample sample;
		public String penID = "0";
		public long gapTime = 0L;

		public ReplayEvent(ReplayEventType t) {
			type = t;
		}
	}

	private static final String PEN_XML_FORMAT = "<pen id=\"(.*?)\".*?/>";
	private static final Pattern PEN_XML_FORMAT_PATTERN = Pattern.compile(PEN_XML_FORMAT);

	private static final String GAP_XML_FORMAT = "<gap time=\"(.*?)\".*?/>";
	private static final Pattern GAP_XML_FORMAT_PATTERN = Pattern.compile(GAP_XML_FORMAT);

	/**
	 * Event Data files are of the form *.eventData.
	 */
	public static final String[] FILE_EXTENSION = new String[] { "eventData" };

	private static SaveAndReplay instance;

	public static synchronized SaveAndReplay getInstance() {
		if (instance == null) {
			instance = new SaveAndReplay();
		}
		return instance;
	}

	private HashMap<InputDevice, PenListener> inputDeviceToListener = new HashMap<InputDevice, PenListener>();

	/**
	 * Events that we can replay...
	 */
	private List<ReplayEvent> eventsToReplay = new ArrayList<ReplayEvent>();

	/**
	 * Allows us to write to our output file for serializing the event stream.
	 */
	private PrintWriter output;

	/**
	 * Should we play back the pen events in real time. That is, if there is a one second pause between two
	 * pen taps, true --> we replicate that one second pause, false --> we replay it as fast as possible.
	 */
	private boolean playEventsInRealTime = true;

	/**
	 * 
	 */
	private InputDevice lastPenUsed;

	private PenSample lastPenSampleTracked;

	/**
	 * Record input at the InputDevice level, and replay to PenListeners.... This should work for multiple
	 * pens...
	 * 
	 * @param inputDevice
	 */
	private SaveAndReplay() {

	}

	private void checkIfNewPen(InputDevice inputDevice) {
		// if it's a new pen, inject some xml to close the previous pen, and open a new one...
		if (inputDevice != lastPenUsed) {
			// add XML tag to tell us a pen was changed...
			output.println("<pen id=\"" + inputDevice.getID() + "\"/>");
		}
		lastPenUsed = inputDevice;
	}

	/**
	 * 
	 */
	public void clearLoadedEvents() {
		eventsToReplay = new ArrayList<ReplayEvent>();
	}

	/**
	 * @return
	 */
	private File getEventStoragePath() {
		return new File(PaperToolkit.getToolkitRootPath(), "eventData/");
	}

	// if we never write to it, the file should never be created...
	private void lazyInitOutputFile() {
		if (output == null) {
			try {
				// Write events to disk (autoflushed), so that we can replay sessions in the
				// future.
				File outputFile = new File(getEventStoragePath(), FileUtils
						.getCurrentTimeForUseInASortableFileName()
						+ ".eventData");
				output = new PrintWriter(new FileOutputStream(outputFile), true /* autoflush */);
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}
		}
	}

	public PenListener getPenListener(final InputDevice inputDevice) {
		PenListener penListener = inputDeviceToListener.get(inputDevice);
		if (penListener == null) {
			penListener = new PenListener() {
				public void penDown(PenSample sample) {
					lazyInitOutputFile();
					checkIfInteractionGap(sample);
					checkIfNewPen(inputDevice);
					saveSample(sample);
				}

				public void penUp(PenSample sample) {
					checkIfNewPen(inputDevice);
					lastPenSampleTracked = sample;
					saveSample(sample);
				}

				public void sample(PenSample sample) {
					checkIfNewPen(inputDevice);
					lastPenSampleTracked = sample;
					saveSample(sample);
				}
			};
			inputDeviceToListener.put(inputDevice, penListener);
		}
		return penListener;
	}

	private void checkIfInteractionGap(PenSample sample) {
		if (lastPenSampleTracked != null) {
			long diff = sample.timestamp - lastPenSampleTracked.timestamp;
			if (diff > 9000) { // 9 seconds
				output.println("<gap time=\"" + diff + "\"/>");
			}
		}
		lastPenSampleTracked = sample;
	}

	/**
	 * 
	 */
	public void importEventDataFromFileChooser() {
		JFileChooser chooser = FileUtils.createNewFileChooser(SaveAndReplay.FILE_EXTENSION);
		chooser.setCurrentDirectory(new File(PaperToolkit.getToolkitRootPath(), "eventData/"));
		chooser.setMultiSelectionEnabled(true);
		int result = chooser.showDialog(null, "Import Event Data");
		if (result == JFileChooser.APPROVE_OPTION) {
			File[] selectedFiles = chooser.getSelectedFiles();
			for (File f : selectedFiles) {
				// DebugUtils.println("Loading " + f);
				loadSessionDataFrom(f);
			}
		}
	}

	/**
	 * @param eventDataFile
	 */
	public void loadSessionDataFrom(File eventDataFile) {
		BufferedReader br;
		try {
			br = new BufferedReader(new FileReader(eventDataFile));
			String inputLine = null;
			while ((inputLine = br.readLine()) != null) {
				ReplayEvent e;
				PenSample sample = PenSample.fromXMLString(inputLine);
				if (sample != null) {
					// this was a real sample
					e = new ReplayEvent(ReplayEventType.SAMPLE);
					e.sample = sample;
					eventsToReplay.add(e);
				} else {
					if (inputLine.startsWith("<pen ")) {
						e = new ReplayEvent(ReplayEventType.PEN_CHANGE);
						Matcher matcher = PEN_XML_FORMAT_PATTERN.matcher(inputLine);
						if (matcher.find()) {
							e.penID = matcher.group(1);
							eventsToReplay.add(e);
						}
					} else if (inputLine.startsWith("<gap ")) {
						e = new ReplayEvent(ReplayEventType.TIME_GAP);
						Matcher matcher = GAP_XML_FORMAT_PATTERN.matcher(inputLine);
						if (matcher.find()) {
							e.gapTime = Long.parseLong(matcher.group(1));
							eventsToReplay.add(e);
						}
					}
				}
			}
			DebugUtils.println("Loaded " + eventsToReplay.size() + " events.");
			br.close();
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}

	}

	/**
	 * Load the most recent event data file...
	 */
	public void loadMostRecentSession() {
		final List<File> eventFiles = FileUtils.listVisibleFiles(getEventStoragePath(), FILE_EXTENSION);
		if (eventFiles.size() > 0) {
			final File mostRecentFile = eventFiles.get(eventFiles.size() - 1);
			DebugUtils.println("Loading Most Recent Session: " + mostRecentFile.getName());
			loadSessionDataFrom(mostRecentFile);
		} else {
			DebugUtils.println("No Event Data Files Found in " + getEventStoragePath());
		}
	}

	/**
	 * Replay the events that have been loaded, in the order that they appear in the list...
	 */
	public void replayLoadedEvents(EventDispatcher dispatcher) {
		replayToEventDispatcher(dispatcher, eventsToReplay);
	}

	/**
	 * Replays the list of events... Ideally, this should play it back at real time or some multiple of
	 * realtime...
	 * 
	 * Threaded, because we do not want any GUI to block when calling this. Alternatively, refactor this into
	 * blocking & nonblocking versions.
	 * 
	 * @param eventDispatcher
	 *            We will dispatch events to this event engine, simulating input from one or more pens...
	 *            eventEngine = engine;
	 * @param events
	 */
	private void replayToEventDispatcher(final EventDispatcher eventDispatcher, final List<ReplayEvent> events) {
		new Thread(new Runnable() {
			public void run() {
				String penID = "0";
				long lastTimeStamp = 0;
				HashMap<String, Boolean> penIsUp = new HashMap<String, Boolean>();

				for (ReplayEvent e : events) {
					switch (e.type) {
					case PEN_CHANGE:
						penID = e.penID;

						// keep track of this pen's down or up state
						if (!penIsUp.keySet().contains(penID)) {
							penIsUp.put(penID, true);
						}
						break;
					case SAMPLE:
						// determine if it is a DOWN, REGULAR, or UP event.... and handle accordingly
						PenSample sample = e.sample;
						PenEventType type;
						if (penIsUp.get(penID)) {
							penIsUp.put(penID, false); // pen just came down
							type = PenEventType.DOWN;
						} else if (sample.isPenUp()) {
							penIsUp.put(penID, true); // pen just lifted
							type = PenEventType.UP;
						} else {
							type = PenEventType.SAMPLE;
						}

						if (playEventsInRealTime && lastTimeStamp != 0) {
							// pause some amount, to replicate realtime...
							long diff = sample.getTimestamp() - lastTimeStamp;
							if (diff > 0) {
								try {
									// play in "real time"
									Thread.sleep(diff);
								} catch (InterruptedException ex) {
								}
							}
						}
						eventDispatcher.handlePenEvent(new PenEvent(penID, "Replay Pen", sample, type, true));
						lastTimeStamp = sample.getTimestamp();
						break;
					case TIME_GAP: // this was an extended gap (compress to 2 secs)
						long gapTime = e.gapTime;
						try {
							Thread.sleep(gapTime);
						} catch (InterruptedException ex) {
						}
						lastTimeStamp = 0; // don't sleep the next time...
						break;
					default:
						break;
					}
				}
				// DebugUtils.println("Done. Replayed " + events.size() + " Events");
			}
		}).start();
	}

	/**
	 * Save this pen event. This is done automatically for events streamed through any Pen, allowing arbitrary
	 * save and replay of user interactions. One event file is created for each "test session."
	 * 
	 * @param event
	 */
	private void saveSample(PenSample sample) {
		output.println(sample.toXMLString());
	}

	public ActionListener getActionListenerForReplayLast() {
		return new ActionListener() {
			public void actionPerformed(ActionEvent e) {

			}
		};
	}

	public ActionListener getActionListenerForChooseSession() {
		return new ActionListener() {
			public void actionPerformed(ActionEvent e) {

			}
		};
	}
}
