package edu.stanford.hci.r3.events.replay;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.List;

import edu.stanford.hci.r3.PaperToolkit;
import edu.stanford.hci.r3.events.EventEngine;
import edu.stanford.hci.r3.events.PenEvent;
import edu.stanford.hci.r3.events.PenEvent.PenEventModifier;
import edu.stanford.hci.r3.pen.PenSample;
import edu.stanford.hci.r3.util.DebugUtils;
import edu.stanford.hci.r3.util.files.FileUtils;

/**
 * <p>
 * This class interacts with the EventEngine to simulate real-time input events. The events can be loaded from
 * disk (XML files), and can be either batched or realtime events. Alternatively, events generated by an
 * actual pen can be saved out to a file, for future replay.
 * </p>
 * <p>
 * <span class="BSDLicense"> This software is distributed under the <a
 * href="http://hci.stanford.edu/research/copyright.txt">BSD License</a>. </span>
 * </p>
 * 
 * @author <a href="http://graphics.stanford.edu/~ronyeh">Ron B Yeh</a> (ronyeh(AT)cs.stanford.edu)
 */
public class EventReplayManager {

	/**
	 * For tab-delimiting the fields in the eventData file.
	 */
	private static final String SEPARATOR = "\t";

	/**
	 * We will dispatch events to this event engine, simulating input from one or more pens...
	 */
	private EventEngine eventEngine;

	/**
	 * Events that we can replay...
	 */
	private ArrayList<PenEvent> loadedEvents;

	/**
	 * Allows us to write to our output file for serializing the event stream.
	 */
	private PrintWriter output;

	/**
	 * Write events to disk (autoflushed), so that we can replay sessions in the future.
	 */
	private File outputFile;

	/**
	 * @param engine
	 */
	public EventReplayManager(EventEngine engine) {
		eventEngine = engine;
	}

	/**
	 * The inverse of createStringFromEvent(...). This creates a PenEvent object from one line of the
	 * eventData file.
	 * 
	 * @param eventString
	 * @return
	 */
	public PenEvent createEventFromString(String eventString) {
		// DebugUtils.println(eventString);
		final String[] fields = eventString.split(SEPARATOR);
		final PenEventModifier modifier = PenEventModifier.valueOf(fields[0]);
		final String penName = fields[2];
		final int penID = Integer.parseInt(fields[1]);
		final long time = Long.parseLong(fields[3]);
		final double x = Double.parseDouble(fields[4]);
		final double y = Double.parseDouble(fields[5]);
		final long ts = Long.parseLong(fields[6]);
		final int f = Integer.parseInt(fields[7]);

		final PenEvent event = new PenEvent(penID, penName, time, new PenSample(x, y, f, ts));
		event.setModifier(modifier);
		return event;
	}

	/**
	 * @param event
	 * @return
	 */
	private String createStringFromEvent(PenEvent event) {
		final PenSample sample = event.getOriginalSample();
		return event.getModifier() + SEPARATOR + event.getPenID() + SEPARATOR + event.getPenName()
				+ SEPARATOR + event.getTimestamp() + SEPARATOR + sample.getX() + SEPARATOR + sample.getY()
				+ SEPARATOR + sample.getTimestamp() + SEPARATOR + sample.getForce();
	}

	/**
	 * @return
	 */
	private File getEventStoragePath() {
		return new File(PaperToolkit.getToolkitRootPath(), "eventData/");
	}

	/**
	 * @return the printWriter to the eventData file. This is initialized lazily, because we do not want to
	 *         create a file if saveEvent is never called.
	 */
	private PrintWriter getOutput() {
		if (output == null) {
			try {
				outputFile = new File(getEventStoragePath(), FileUtils
						.getCurrentTimeForUseInASortableFileName()
						+ ".eventData");
				output = new PrintWriter(new FileOutputStream(outputFile), true /* autoflush */);
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}
		}
		return output;
	}

	/**
	 * Load the most recent event data file...
	 */
	public void loadMostRecentEventData() {
		final List<File> eventFiles = FileUtils.listVisibleFiles(getEventStoragePath(),
				new String[] { "eventData" });
		loadedEvents = new ArrayList<PenEvent>();
		if (eventFiles.size() > 0) {
			final File mostRecentFile = eventFiles.get(eventFiles.size() - 1);
			DebugUtils.println(mostRecentFile);
			BufferedReader br;
			try {
				br = new BufferedReader(new FileReader(mostRecentFile));
				String inputLine = null;
				while ((inputLine = br.readLine()) != null) {
					PenEvent event = createEventFromString(inputLine);
					loadedEvents.add(event);
				}
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			} catch (IOException e) {
				e.printStackTrace();
			}

		}
	}

	/**
	 * Replays the list of events... Ideally, this should play it back at real time or some multiple of
	 * realtime...
	 * 
	 * @param events
	 */
	public void replay(List<PenEvent> events) {
		long lastTimeStamp = 0;

		for (PenEvent event : events) {
			if (lastTimeStamp != 0) {
				// pause some amount, to replicate realtime...
				long diff = event.getTimestamp() - lastTimeStamp;
				try {
					Thread.sleep(diff);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}

			// assume here that all PenEvent objects have their flags set correctly
			if (event.isPenUp()) {
				eventEngine.handlePenUpEvent(event);
			} else {
				eventEngine.handlePenEvent(event);
			}

			lastTimeStamp = event.getTimestamp();
		}
	}

	/**
	 * Replay the events that have been loaded, in the order that they appear in the list...
	 */
	public void replayLoadedEvents() {
		replay(loadedEvents);
	}

	/**
	 * @param event
	 */
	public void saveEvent(PenEvent event) {
		getOutput().println(createStringFromEvent(event));
	}
}
